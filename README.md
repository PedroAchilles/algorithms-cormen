# ðŸ“˜ Algorithms â€“ Cormen Study Repository

This repository is a personal study project based on the book *"Introduction to Algorithms"* by Cormen, Leiserson, Rivest, and Stein (CLRS) - 4th edition.  
It contains:

- ðŸ“„ Summaries of each chapter in **Portuguese and English**
- ðŸ’» Implementations of algorithms in **Java**
- ðŸ“ˆ Benchmark experiments and visualizations (to be added)

## ðŸ“š Structure

- `summaries/`: Chapter summaries (`.md`), in both languages
- `implementations/`: Java implementations of key algorithms
- `benchmarks/`: Performance comparisons (coming soon)

## ðŸ”§ Technologies

- Java
- Markdown
- Git/GitHub

## âœ… Progress

## Part I | Foundations

- [x] 1 | The Role of Algorithms in Computing
- [x] 1.1 Algorithms
- [x] 1.2 Algorithms as a Technology
- [ ] 2 | Getting Started
- [ ] 2.1 Insertion Sort
- [ ] 2.2 Analyzing Algorithms
- [ ] 2.3 Designing Algorithms
- [ ] 2.3.1 The Divide-and-Conquer Approach
- [ ] 2.3.2 Analyzing Divide-and-Conquer Algorithms
- [ ] 3 | Growth of Functions
- [ ] 3.1 Asymptotic Notation
- [ ] 3.2 Standard Notations and Common Functions
- [ ] 4 | Divide-and-Conquer
- [ ] 4.1 The Maximum Subarray Problem
- [ ] 4.2 Strassenâ€™s Algorithm for Matrix Multiplication
- [ ] 4.3 The Substitution Method for Solving Recurrences
- [ ] 4.4 The Recursion-Tree Method for Solving Recurrences
- [ ] 4.5 The Master Method for Solving Recurrences
- [ ] 4.6 Proof of the Master Theorem
- [ ] 4.6.1 The Proof for Exact Powers
- [ ] 4.6.2 Floors and Ceilings
- [ ] 5 | Probabilistic Analysis and Randomized Algorithms
- [ ] 5.1 The Hiring Problem
- [ ] 5.2 Indicator Random Variables
- [ ] 5.3 Randomized Algorithms
- [ ] 5.4 Probabilistic Analysis and Further Uses of Indicator Variables
- [ ] 5.4.1 The Birthday Paradox
- [ ] 5.4.2 Balls and Bins
- [ ] 5.4.3 Streaks
- [ ] 5.4.4 Online Hiring Problem

## Part II | Sorting and Order Statistics

- [ ] 6 | Heapsort
- [ ] 6.1 Heaps
- [ ] 6.2 Maintaining the Heap Property
- [ ] 6.3 Building a Heap
- [ ] 6.4 The Heapsort Algorithm
- [ ] 6.5 Priority Queues
- [ ] 7 | Quicksort
- [ ] 7.1 Description of Quicksort
- [ ] 7.2 Performance of Quicksort
- [ ] 7.3 A Randomized Version of Quicksort
- [ ] 7.4 Analysis of Quicksort
- [ ] 7.4.1 Worst-Case Analysis
- [ ] 7.4.2 Expected Running Time
- [ ] 8 | Sorting in Linear Time
- [ ] 8.1 Lower Bounds for Sorting
- [ ] 8.2 Counting Sort
- [ ] 8.3 Radix Sort
- [ ] 8.4 Bucket Sort
- [ ] 9 | Medians and Order Statistics
- [ ] 9.1 Minimum and Maximum
- [ ] 9.2 Expected Linear-Time Selection
- [ ] 9.3 Worst-Case Linear-Time Selection

## Part III | Data Structures

- [ ] 10 | Elementary Data Structures
- [ ] 10.1 Stacks and Queues
- [ ] 10.2 Linked Lists
- [ ] 10.3 Implementing Pointers and Objects
- [ ] 10.4 Representing Rooted Trees
- [ ] 11 | Hash Tables
- [ ] 11.1 Direct-Address Tables
- [ ] 11.2 Hash Tables
- [ ] 11.3 Hash Functions
- [ ] 11.3.1 The Division Method
- [ ] 11.3.2 The Multiplication Method
- [ ] 11.3.3 Universal Hashing
- [ ] 11.4 Open Addressing
- [ ] 11.5 Perfect Hashing
- [ ] 12 | Binary Search Trees
- [ ] 12.1 What is a Binary Search Tree?
- [ ] 12.2 Querying a Binary Search Tree
- [ ] 12.3 Insertion and Deletion
- [ ] 12.4 Randomly Built Binary Search Trees
- [ ] 13 | Red-Black Trees
- [ ] 13.1 Properties of Red-Black Trees
- [ ] 13.2 Rotations
- [ ] 13.3 Insertion
- [ ] 13.4 Deletion
- [ ] 14 | Augmenting Data Structures
- [ ] 14.1 Dynamic Order Statistics
- [ ] 14.2 How to Augment a Data Structure
- [ ] 14.3 Interval Trees

## Part IV | Advanced Design and Analysis Techniques

- [ ] 15 | Dynamic Programming
- [ ] 15.1 Rod Cutting
- [ ] 15.2 Matrix-Chain Multiplication
- [ ] 15.3 Elements of Dynamic Programming
- [ ] 15.4 Longest Common Subsequence
- [ ] 15.5 Optimal Binary Search Trees
- [ ] 16 | Greedy Algorithms
- [ ] 16.1 An Activity-Selection Problem
- [ ] 16.2 Elements of the Greedy Strategy
- [ ] 16.3 Huffman Codes
- [ ] 16.4 Matroids and Greedy Methods
- [ ] 16.5 A Task-Scheduling Problem as a Matroid
- [ ] 17 | Amortized Analysis
- [ ] 17.1 Aggregate Analysis
- [ ] 17.2 The Accounting Method
- [ ] 17.3 The Potential Method
- [ ] 17.4 Dynamic Tables
- [ ] 17.4.1 Table Expansion
- [ ] 17.4.2 Table Expansion and Contraction

## Part V | Advanced Data Structures

- [ ] 18 | B-Trees
- [ ] 18.1 Definition of B-Trees
- [ ] 18.2 Basic Operations on B-Trees
- [ ] 18.3 Deleting a Key from a B-Tree
- [ ] 19 | Fibonacci Heaps
- [ ] 19.1 Structure of Fibonacci Heaps
- [ ] 19.2 Mergeable-Heap Operations
- [ ] 19.3 Decreasing a Key and Deleting a Node
- [ ] 19.4 Bounding the Maximum Degree
- [ ] 20 | van Emde Boas Trees
- [ ] 20.1 Preliminary Approaches
- [ ] 20.2 A Recursive Structure
- [ ] 20.2.1 Protoâ€“van Emde Boas Structures
- [ ] 20.2.2 Operations on a Protoâ€“van Emde Boas Structure
- [ ] 20.3 The van Emde Boas Tree
- [ ] 20.3.1 The van Emde Boas Tree
- [ ] 20.3.2 Operations on a van Emde Boas Tree
- [ ] 21 | Data Structures for Disjoint Sets
- [ ] 21.1 Disjoint-Set Operations
- [ ] 21.2 Linked-List Representation of Disjoint Sets
- [ ] 21.3 Disjoint-Set Forests
- [ ] 21.4 Analysis of Union by Rank with Path Compression

## Part VI | Graph Algorithms

- [ ] 22 | Elementary Graph Algorithms
- [ ] 22.1 Representations of Graphs
- [ ] 22.2 Breadth-First Search
- [ ] 22.3 Depth-First Search
- [ ] 22.4 Topological Sort
- [ ] 22.5 Strongly Connected Components
- [ ] 23 | Minimum Spanning Trees
- [ ] 23.1 Growing a Minimum Spanning Tree
- [ ] 23.2 The Algorithms of Kruskal and Prim
- [ ] 24 | Single-Source Shortest Paths
- [ ] 24.1 The Bellman-Ford Algorithm
- [ ] 24.2 Single-Source Shortest Paths in Directed Acyclic Graphs
- [ ] 24.3 Dijkstraâ€™s Algorithm
- [ ] 24.4 Difference Constraints and Shortest Paths
- [ ] 24.5 Proofs of Shortest-Path Properties
- [ ] 25 | All-Pairs Shortest Paths
- [ ] 25.1 Shortest Paths and Matrix Multiplication
- [ ] 25.2 The Floyd-Warshall Algorithm
- [ ] 25.3 Johnsonâ€™s Algorithm for Sparse Graphs
- [ ] 26 | Maximum Flow
- [ ] 26.1 Flow Networks
- [ ] 26.2 The Ford-Fulkerson Method
- [ ] 26.3 Maximum Bipartite Matching
- [ ] 26.4 Push-Relabel Algorithms
- [ ] 26.5 The Relabel-to-Front Algorithm

## Part VII | Selected Topics

- [ ] 27 | Multithreaded Algorithms
- [ ] 27.1 Basics of Dynamic Multithreading
- [ ] 27.2 Multithreaded Matrix Multiplication
- [ ] 27.3 Multithreaded Merge Sort
- [ ] 28 | Matrix Operations
- [ ] 28.1 Solving Systems of Linear Equations
- [ ] 28.2 Inverting Matrices
- [ ] 28.3 Symmetric Positive-Definite Matrices and Least-Squares Approximation
- [ ] 29 | Linear Programming
- [ ] 29.1 Standard and Slack Forms
- [ ] 29.2 Formulating Problems as Linear Programs
- [ ] 29.3 The Simplex Algorithm
- [ ] 29.4 Duality
- [ ] 29.5 The Initial Basic Feasible Solution
- [ ] 30 | Polynomials and the FFT
- [ ] 30.1 Representing Polynomials
- [ ] 30.2 The DFT and FFT
- [ ] 30.3 Efficient FFT Implementations
- [ ] 31 | Number-Theoretic Algorithms
- [ ] 31.1 Elementary Number-Theoretic Notions
- [ ] 31.2 Greatest Common Divisor
- [ ] 31.3 Modular Arithmetic
- [ ] 31.4 Solving Modular Linear Equations
- [ ] 31.5 The Chinese Remainder Theorem
- [ ] 31.6 Powers of an Element
- [ ] 31.7 The RSA Public-Key Cryptosystem
- [ ] 31.8 Primality Testing
- [ ] 31.9 Integer Factorization
- [ ] 32 | String Matching
- [ ] 32.1 The Naive String-Matching Algorithm
- [ ] 32.2 The Rabin-Karp Algorithm
- [ ] 32.3 String Matching with Finite Automata
- [ ] 32.4 The Knuth-Morris-Pratt Algorithm
- [ ] 33 | Computational Geometry
- [ ] 33.1 Line-Segment Properties
- [ ] 33.2 Determining Whether Any Two Segments Intersect
- [ ] 33.3 Finding the Convex Hull
- [ ] 33.4 Finding the Closest Pair of Points
- [ ] 34 | NP-Completeness
- [ ] 34.1 Polynomial Time
- [ ] 34.2 Polynomial-Time Verification
- [ ] 34.3 NP-Completeness and Reducibility
- [ ] 34.4 NP-Completeness Proofs
- [ ] 34.5 NP-Complete Problems
- [ ] 34.5.1 The Clique Problem
- [ ] 34.5.2 The Vertex-Cover Problem
- [ ] 34.5.3 The Hamiltonian-Cycle Problem
- [ ] 34.5.4 The Traveling-Salesman Problem
- [ ] 34.5.5 The Subset-Sum Problem
- [ ] 35 | Approximation Algorithms
- [ ] 35.1 The Vertex-Cover Problem
- [ ] 35.2 The Traveling-Salesman Problem
- [ ] 35.2.1 The TSP with Triangle Inequality
- [ ] 35.2.2 The General TSP Problem
- [ ] 35.3 The Set-Covering Problem
- [ ] 35.4 Randomization and Linear Programming
- [ ] 35.5 The Subset-Sum Problem

## ðŸ“Œ Disclaimer

This project is for educational purposes only. It is not affiliated with or endorsed by the authors of the book.
